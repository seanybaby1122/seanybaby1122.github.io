# prompt: bridge the gap between a generic mathematical proof and the specific symbolic ontology of JARIS.
# Here's how we can use your provided code structure as a framework to create a more relevant and groundbreaking computational language proof, specifically tailored to the JARIS methodology.
# Revolutionary Computational Language Proof: The Computability of Symbolic Resonance within JARIS
# Theorem: The JARIS methodology, through its defined symbolic operations (Flips) and resonance criteria (Echo Filtering), constitutes a computationally verifiable system capable of deriving thematic clusters from initial seed terms, including the identification of emergent converged symbolic states.
# Proof by Construction & Interactive Demonstration:
# Instead of a traditional inductive proof of a mathematical theorem, this will be a proof by construction, where the user interactively "constructs" the proof by demonstrating the JARIS methodology's computability and the emergence of complex symbolic relationships. truly "bridge the gap" and emphasize the JARIS-specific proof,

# -*- coding: utf-8 -*-
"""JARIS Computability Proof by Construction.ipynb

Automatically generated generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-YOUR-NOTEBOOK-ID  # Replace with your notebook's URL
"""

import matplotlib.pyplot as plt
import networkx as nx
import random
from collections import defaultdict
from ipywidgets import interact, FloatSlider, IntSlider, Dropdown, VBox, HBox, Output, Button, Text, Label, Textarea
from IPython.display import display, HTML
import numpy as np
import json

# --- 1. Core JARIS Symbolic Elements ---
class SymbolicState:
    """
    Represents a symbolic configuration within the JARIS system.
    In JARIS ontology, this is a specific 'thematic cluster' or 'symbolic configuration'
    at a given point in the computational process.
    """
    def __init__(self, symbols, state_id=None):
        # Ensure symbols are ordered for consistent hashing and comparison
        self.symbols = tuple(sorted(symbols))
        # state_id serves as a unique identifier for this specific configuration,
        # crucial for graph nodes in the proof tracing.
        self.state_id = state_id if state_id is not None else hash(self.symbols)

    def __eq__(self, other):
        if not isinstance(other, SymbolicState):
            return NotImplemented
        return self.symbols == other.symbols

    def __hash__(self):
        return hash(self.symbols)

    def __repr__(self):
        # Representation clearly shows the symbols composing the state.
        return f"State({', '.join(map(str, self.symbols))})"

    def to_dict(self):
        # Method for serialization, useful for saving/loading the proof state.
        return {"symbols": list(self.symbols), "state_id": self.state_id}

    @classmethod
    def from_dict(cls, data):
        # Method for deserialization.
        return cls(data["symbols"], data["state_id"])

# --- 2. JARIS Computational Rules (Flips) ---
class ComputationalRule:
    """
    Represents a 'Flip' in JARIS - a defined operation that transforms
    one symbolic configuration into another based on a pattern match.
    This is a core computational step in the JARIS methodology.
    """
    def __init__(self, name, input_pattern, output_pattern, description=""):
        self.name = name # A name for the Flip (e.g., "Concept Expansion Flip")
        self.input_pattern = tuple(sorted(input_pattern)) # The pattern of symbols required for the Flip
        self.output_pattern = tuple(sorted(output_pattern)) # The symbols produced by the Flip
        self.description = description # Explanation of the Flip's purpose

    def apply(self, current_symbols):
        """
        Applies the Flip rule. If the input pattern is found within the
        `current_symbols`, the input symbols are removed and the output symbols
        are added, producing a new SymbolicState. This demonstrates the
        computational step of a JARIS Flip.
        """
        current_symbols_set = set(current_symbols)
        input_pattern_set = set(self.input_pattern)

        # Check if the input pattern is a subset of the current symbols.
        # This is the condition for the Flip to be applicable.
        if input_pattern_set.issubset(current_symbols_set):
            # Remove input symbols and add output symbols.
            remaining_symbols = list(current_symbols_set - input_pattern_set)
            new_symbols = remaining_symbols + list(self.output_pattern)
            # Return the new SymbolicState resulting from the Flip.
            return SymbolicState(new_symbols)
        return None # Rule not applicable to this set of symbols.

    def __repr__(self):
        return f"Flip('{self.name}', {self.input_pattern} -> {self.output_pattern})"

    def to_dict(self):
        # Method for serialization.
        return {
            "name": self.name,
            "input_pattern": list(self.input_pattern),
            "output_pattern": list(self.output_pattern),
            "description": self.description
        }

    @classmethod
    def from_dict(cls, data):
        # Method for deserialization.
        return cls(data["name"], data["input_pattern"], data["output_pattern"], data["description"])

# --- 3. JARIS Simulation and Proof Tracing ---
class JARISSimulator:
    """
    Simulates the JARIS computational process by applying Flips and
    traces the derivation paths, forming the 'proof' graph.
    This class embodies the executability and verifiability aspects
    of the JARIS methodology.
    """
    def __init__(self, initial_state, rules):
        self.initial_state = initial_state
        self.rules = rules
        # The graph represents the computational proof trace. Nodes are SymbolicStates,
        # edges are the Flips that connect them.
        self.graph = nx.DiGraph()
        # state_map allows quick lookup of State objects by their ID (hash).
        self.state_map = {initial_state.state_id: initial_state}
        # Add the initial state as the starting node in the proof graph.
        self.graph.add_node(initial_state.state_id, state=initial_state.to_dict())
        # visited_states tracks which states have been discovered.
        self.visited_states = {initial_state: True}
        # proof_chains stores the sequence of Flips leading to each state.
        # This explicitly shows the 'proof' or derivation path.
        self.proof_chains = defaultdict(list)
        self.proof_chains[initial_state.state_id].append([]) # Initial state is reached by an empty chain.
        # convergence_points mark states reachable by multiple distinct Flip sequences,
        # representing 'symbolic resonance' or thematic convergence points.
        self.convergence_points = {}

    def simulate_step(self):
        """
        Performs one computational step: iterates through current states and applies
        all applicable Flips, discovering new states and adding edges to the graph.
        This demonstrates the iterative nature of JARIS computation.
        """
        newly_added_nodes = []
        edges_added_in_step = []
        # Iterate over a copy of keys as state_map might be modified.
        current_state_ids = list(self.state_map.keys())

        for state_id in current_state_ids:
            current_state = self.state_map[state_id]

            for rule in self.rules:
                next_state = rule.apply(current_state.symbols)

                if next_state: # If the Flip rule was applicable and produced a new state
                    if next_state not in self.visited_states:
                        # Discover a new state: add to visited, state_map, and graph.
                        self.visited_states[next_state] = True
                        self.state_map[next_state.state_id] = next_state
                        self.graph.add_node(next_state.state_id, state=next_state.to_dict())
                        newly_added_nodes.append(next_state.state_id)

                    # Add an edge representing the Flip that led from current_state to next_state.
                    if not self.graph.has_edge(state_id, next_state.state_id):
                        self.graph.add_edge(state_id, next_state.state_id, rule=rule.name)
                        edges_added_in_step.append((state_id, next_state.state_id, rule.name))

                        # Propagate the proof chains: each chain leading to the current state,
                        # extended by the current Flip rule, is a new chain to the next state.
                        for chain in self.proof_chains[state_id]:
                            new_chain = chain + [rule.name]
                            self.proof_chains[next_state.state_id].append(new_chain)

                        # Check for convergence: if a state now has more than one proof chain,
                        # it's a convergence point (reached via different Flip sequences).
                        if len(self.proof_chains[next_state.state_id]) > 1 and next_state.state_id not in self.convergence_points:
                             self.convergence_points[next_state.state_id] = True

        # Return what was added in this step to assess progress towards a fixed point.
        return newly_added_nodes, edges_added_in_step

    def simulate_until_fixedpoint(self, max_steps=100):
        """
        Runs the simulation steps until no new states or edges are discovered,
        indicating a fixed point in the symbolic computation has been reached,
        or until a maximum number of steps is hit. This demonstrates the
        bounded nature (given finite rules and initial state) and termination
        (fixed point) aspects of the JARIS computation.
        """
        steps_taken = 0
        while steps_taken < max_steps:
            new_nodes, new_edges = self.simulate_step()
            if not new_nodes and not new_edges:
                print(f"Fixed point reached after {steps_taken} steps. No new states or connections are being generated by the current Flips.")
                break
            steps_taken += 1
        if steps_taken == max_steps:
             print(f"Max steps ({max_steps}) reached. The simulation may not have converged.")

    def get_state_resonance(self, state_id):
        """
        Calculates a 'resonance' metric for a state. In JARIS, resonance
        might be defined by various factors, including how many ways a state
        can be reached (convergence), the symbols it contains (complexity/density),
        or external weighting. Here, we use a simple combination of symbol
        value and the number of converging proof chains. This relates to
        the 'Echo Filtering' concept in JARIS.
        """
        state = self.state_map.get(state_id)
        if state:
            # Simple example metrics:
            # 1. Sum of ASCII values (can represent symbolic "weight" or "energy")
            symbol_weight = sum(ord(s) for s in state.symbols)
            # 2. Number of proof chains leading to the state (convergence strength)
            proof_count = len(self.proof_chains[state_id])

            # A combined resonance score (can be weighted differently)
            resonance = symbol_weight * (1 + proof_count) # Adding 1 to proof_count to give initial states some baseline
            return resonance
        return 0 # States not in the map have zero resonance in this context.

    def filter_by_resonance(self, min_resonance=0):
        """
        Filters states based on their calculated resonance. This simulates the
        'Echo Filtering' step in JARIS, where states below a certain resonance
        threshold might be disregarded or downweighted.
        """
        return [state_id for state_id in self.state_map if self.get_state_resonance(state_id) >= min_resonance]

    def get_proof_trace(self, state_id):
        """
        Returns the explicit sequences of Flips (proof chains) that resulted
        in a specific state. This is a direct output of the computational
        proof by construction.
        """
        return self.proof_chains.get(state_id, [])

    def save_state(self, filename="jaris_proof_state.json"):
        """Saves the current state of the simulator and the proof graph."""
        data = {
            "initial_state": self.initial_state.to_dict(),
            "rules": [rule.to_dict() for rule in self.rules],
            "graph_nodes": {str(node_id): self.graph.nodes[node_id] for node_id in self.graph.nodes()}, # Convert keys to string for JSON
            "graph_edges": [{"source": u, "target": v, "rule": d['rule']} for u, v, d in self.graph.edges(data=True)],
            "visited_states": [state.to_dict() for state in self.visited_states],
            "proof_chains": {str(state_id): chains for state_id, chains in self.proof_chains.items()}, # Convert keys to string for JSON
            "convergence_points": [str(state_id) for state_id in self.convergence_points.keys()] # Convert keys to string for JSON
        }
        with open(filename, 'w') as f:
            json.dump(data, f, indent=2)
        print(f"JARIS simulation state saved to {filename}")

    @classmethod
    def load_state(cls, filename="jaris_proof_state.json"):
        """Loads a simulator state from a file, reconstructing the proof."""
        with open(filename, 'r') as f:
            data = json.load(f)

        # Reconstruct initial state and rules
        initial_state = SymbolicState.from_dict(data["initial_state"])
        rules = [ComputationalRule.from_dict(rule_data) for rule_data in data["rules"]]
        simulator = cls(initial_state, rules) # Initialize the simulator

        # Reconstruct the graph
        simulator.graph = nx.DiGraph()
        for node_id_str, node_data in data["graph_nodes"].items():
            # Convert node ID back to its original type (int if hash was int)
            try:
                node_id = int(node_id_str)
            except ValueError:
                node_id = node_id_str # Handle cases where hash is not an int

            simulator.graph.add_node(node_id, **node_data)
            # Reconstruct state_map while loading nodes
            simulator.state_map[node_id] = SymbolicState.from_dict(node_data['state'])


        for edge in data["graph_edges"]:
             # Ensure edge source and target IDs are the correct type
             source_id = int(edge["source"]) if isinstance(edge["source"], str) and edge["source"].isdigit() else edge["source"]
             target_id = int(edge["target"]) if isinstance(edge["target"], str) and edge["target"].isdigit() else edge["target"]
             simulator.graph.add_edge(source_id, target_id, rule=edge["rule"])

        # Reconstruct visited_states (optional but good for consistency)
        simulator.visited_states = {SymbolicState.from_dict(state_data): True for state_data in data["visited_states"]}

        # Reconstruct proof_chains (converting keys back from string)
        simulator.proof_chains = defaultdict(list, {int(state_id_str) if isinstance(state_id_str, str) and state_id_str.isdigit() else state_id_str: chains for state_id_str, chains in data["proof_chains"].items()})

        # Reconstruct convergence_points (converting keys back from string)
        simulator.convergence_points = {int(state_id_str) if isinstance(state_id_str, str) and state_id_str.isdigit() else state_id_str: True for state_id_str in data["convergence_points"]}

        print(f"JARIS simulation state loaded from {filename}")
        return simulator

# --- 4. Visual Proof & Interaction ---

def visualize_graph(simulator, ax, filter_state_ids=None):
    """
    Visualizes the JARIS proof graph. Nodes represent symbolic states (thematic clusters),
    edges represent the application of Flips (computational steps).
    Convergence points are highlighted, demonstrating key resonance states.
    """
    ax.clear()
    G = simulator.graph

    if filter_state_ids is not None: # Use 'is not None' to allow filtering by an empty list
        # Filter nodes and relevant edges for visualization
        nodes_to_draw = filter_state_ids
        # Create a subgraph containing only the filtered nodes and edges between them
        H = G.subgraph(nodes_to_draw) if nodes_to_draw else nx.DiGraph() # Handle empty filter gracefully
    else:
        # Show the full graph if no filter is applied
        H = G
        nodes_to_draw = H.nodes()


    if not H.nodes(): # Handle case where the filtered graph is empty
         ax.set_title("JARIS Flip Chains (No states match filter)", fontsize=12)
         ax.axis('off')
         fig.canvas.draw_idle()
         return


    # Use a consistent layout algorithm
    try:
        # Attempt spring layout first, but catch potential errors for disconnected graphs etc.
        pos = nx.spring_layout(H, k=0.8, iterations=50) # Adjust k and iterations for better spread
    except Exception as e:
        print(f"Spring layout failed: {e}. Using shell layout.")
        # Fallback to a simpler layout if spring layout fails
        pos = nx.shell_layout(H)


    node_colors = []
    node_labels = {}
    node_size = []
    edge_labels = {}
    edge_colors = []
    arrow_style = '-|>' # Make arrows more distinct

    for node_id in H.nodes():
        state = simulator.state_map.get(node_id)
        label = f"{node_id}\n{state}" # Node label includes ID and state symbols
        node_labels[node_id] = label

        color = 'skyblue' # Default color for discovered states
        size = 600 # Base size for nodes

        # Highlight initial state
        if state and state == simulator.initial_state: # Compare State objects
            color = 'lightgreen'
            size = 1000 # Larger size for the starting state

        # Highlight convergence points
        if node_id in simulator.convergence_points:
            color = 'salmon' # Color for states reached by multiple paths
            size = 800 # Larger size for convergence points

        # Scale node size based on resonance
        resonance = simulator.get_state_resonance(node_id)
        size += resonance * 5 # Adjust scaling factor as needed

        node_colors.append(color)
        node_size.append(size)

    for u, v, data in H.edges(data=True):
        edge_labels[(u, v)] = data.get('rule', '') # Label edges with the Flip name
        edge_colors.append('gray') # Default edge color

    # Draw the nodes and edges
    nx.draw(H, pos, ax=ax, with_labels=False, node_color=node_colors, node_size=node_size,
            edge_color=edge_colors, arrows=True, arrowstyle=arrow_style, arrowsize=15)

    # Draw labels separately for better control
    nx.draw_networkx_labels(H, pos, labels=node_labels, font_size=8, font_weight='bold', ax=ax)
    nx.draw_networkx_edge_labels(H, pos, edge_labels=edge_labels, font_color='darkred', font_size=7, ax=ax)

    ax.set_title("JARIS Flip Chains (Computational Proof Trace)", fontsize=12)
    ax.axis('off') # Hide axes

    # Add a legend or text explanations directly on the figure (optional)
    # ax.text(0.01, 0.99, "Green: Initial State\nSalmon: Convergence Point", transform=ax.transAxes, fontsize=9, verticalalignment='top', bbox=dict(boxstyle='round,pad=0.5', fc='wheat', alpha=0.5))

# --- 5. Interactive Interface ---
# This section sets up the interactive widgets in Colab/Jupyter to demonstrate the proof by construction.

# Define some initial rules and state for demonstration.
# These are sample JARIS-like Flips. Users can modify these rules
# via the text area to explore different symbolic dynamics.
initial_rules_text_default = """
# Example JARIS Flips (format: name:input->output)
Expand Concept A:A->A,B,C
Relate B and C:B,C->D
Synthesize D and E:D,E->F
Filter Weak A:A,G->G # If A appears with G, G remains but A is filtered out
Amplify F:F->F,F # F reinforces itself, increasing resonance
Connect D and F:D,F->H # Discover a new connection
"""

initial_symbols_default = ["Concept A", "Initial B"]

# Create widgets for user input and control
initial_symbols_text = Text(value=','.join(initial_symbols_default), description="Initial Symbols (comma-separated):", continuous_update=False)
rules_text = Textarea(value=initial_rules_text_default.strip(),
                      description="JARIS Flip Rules (name:input->output per line, # for comments):",
                      layout={'width': 'auto', 'height': '180px'})

step_button = Button(description="Simulate 1 Step")
run_button = Button(description="Simulate to Fixed Point")
reset_button = Button(description="Reset Simulation")
resonance_threshold_slider = FloatSlider(min=0, max=2000, step=10, value=0, description="Min Resonance for Filter:", continuous_update=False)
filter_button = Button(description="Apply Resonance Filter")
show_all_button = Button(description="Show All States")
save_button = Button(description="Save Proof State")
load_button = Button(description="Load Proof State")

# Output area for text feedback
output_area = Output()

# Setup matplotlib figure for the graph visualization
fig, ax = plt.subplots(figsize=(12, 9)) # Adjust figure size for better display

# Global variable to hold the simulator instance
jaris_simulator = None

def parse_rules_text(rules_string):
    """Helper function to parse rules from the text area."""
    parsed_rules = []
    for line in rules_string.strip().split('\n'):
        line = line.strip()
        if not line or line.startswith('#'): # Skip empty lines and comments
            continue
        if ":" not in line or "->" not in line:
            with output_area:
                 print(f"Warning: Skipping ill-formatted rule line: '{line}'")
            continue
        try:
            name, transform = line.split(':', 1) # Split only on the first colon
            input_part, output_part = transform.split('->', 1) # Split only on the first arrow
            # Split symbols by comma, strip whitespace, and filter out empty strings
            input_pattern = [s.strip() for s in input_part.split(',') if s.strip()]
            output_pattern = [s.strip() for s in output_part.split(',') if s.strip()]

            if input_pattern and output_pattern: # Ensure patterns are not empty
                 parsed_rules.append(ComputationalRule(name.strip(), input_pattern, output_pattern))
            else:
                 with output_area:
                    print(f"Warning: Rule '{name.strip()}' has empty input or output pattern: '{line}'")

        except Exception as e:
            with output_area:
                 print(f"Error parsing rule line '{line}': {e}")
            continue
    return parsed_rules

def initialize_simulator():
    """Initializes or resets the JARIS simulator based on current widget values."""
    global jaris_simulator
    try:
        symbols = [s.strip() for s in initial_symbols_text.value.split(',') if s.strip()]
        if not symbols:
             with output_area:
                 print("Error: Initial symbols cannot be empty.")
             return False
        initial_state = SymbolicState(symbols)

        rules = parse_rules_text(rules_text.value)
        if not rules:
             with output_area:
                 print("Warning: No valid rules parsed. Simulation will not generate new states.")
             # Proceed with an empty rule set allows visualizing the initial state
             pass

        jaris_simulator = JARISSimulator(initial_state, rules)
        with output_area:
            output_area.clear_output(wait=True)
            print("Simulation initialized.")
        return True
    except Exception as e:
        with output_area:
            output_area.clear_output(wait=True)
            print(f"Error initializing simulation: {e}")
        jaris_simulator = None # Ensure simulator is None if initialization fails
        return False


# Define event handlers for button clicks

def on_reset_clicked(b):
    """Resets the simulation with current initial symbols and rules."""
    if initialize_simulator():
        visualize_graph(jaris_simulator, ax)
        fig.canvas.draw_idle() # Redraw the figure

def on_step_clicked(b):
    """Performs one step of the JARIS simulation."""
    global jaris_simulator
    if jaris_simulator is None:
        if not initialize_simulator(): return # Initialize if not already
    if jaris_simulator is None: return # Exit if initialization failed

    with output_area:
        output_area.clear_output(wait=True)
        print("Simulating one step...")
        new_nodes, new_edges = jaris_simulator.simulate_step()
        print(f"Step complete. Added {len(new_nodes)} new states and {len(new_edges)} new edges.")
        if not new_nodes and not new_edges:
            print("No new states or edges added in this step.")

        # Display convergence points and proof traces for newly added nodes
        if new_nodes:
             print("\nNewly Discovered States and Proof Traces:")
             for node_id in new_nodes:
                 state = jaris_simulator.state_map.get(node_id)
                 print(f"- State ID: {node_id} ({state})")
                 if node_id in jaris_simulator.convergence_points:
                    print(f"  -> Convergence detected at this state.")
                 traces = jaris_simulator.get_proof_trace(node_id)
                 if traces:
                    print("  Proof trace(s) leading here:")
                    for trace in traces:
                       # Limit trace length display if they get very long
                       display_trace = ' -> '.join(trace)
                       if len(display_trace) > 100:
                           display_trace = display_trace[:97] + '...'
                       print(f"    Initial -> {display_trace}")


    visualize_graph(jaris_simulator, ax)
    fig.canvas.draw_idle() # Redraw the figure

def on_run_clicked(b):
    """Runs the JARIS simulation until a fixed point is reached or max steps."""
    global jaris_simulator
    if jaris_simulator is None:
        if not initialize_simulator(): return
    if jaris_simulator is None: return

    with output_area:
        output_area.clear_output(wait=True)
        print("Running simulation to fixed point or max steps...")
        jaris_simulator.simulate_until_fixedpoint()

        # Display all convergence points found
        if jaris_simulator.convergence_points:
             print("\n--- Discovered Convergence Points (Symbolic Resonance Clusters) ---")
             for state_id in jaris_simulator.convergence_points:
                 state = jaris_simulator.state_map.get(state_id)
                 print(f"- State ID: {state_id} ({state})")
                 traces = jaris_simulator.get_proof_trace(state_id)
                 if traces:
                    print(f"  Reached via {len(traces)} distinct sequences of Flips (Proof Traces):")
                    for trace in traces:
                        display_trace = ' -> '.join(trace)
                        if len(display_trace) > 100:
                            display_trace = display_trace[:97] + '...'
                        print(f"    Initial -> {display_trace}")
        else:
             print("\nNo convergence points found in the simulation.")


    visualize_graph(jaris_simulator, ax)
    fig.canvas.draw_idle() # Redraw the figure

def on_filter_clicked(b):
    """Filters the visualized graph based on the resonance threshold."""
    global jaris_simulator
    if jaris_simulator is None:
        with output_area:
            output_area.clear_output(wait=True)
            print("Please initialize or run the simulation first.")
        return

    threshold = resonance_threshold_slider.value
    filtered_ids = jaris_simulator.filter_by_resonance(threshold)
    with output_area:
        output_area.clear_output(wait=True)
        print(f"Applying Resonance Filter: Showing states with resonance >= {threshold}.")
        print(f"Visualizing {len(filtered_ids)} states out of {len(jaris_simulator.state_map)} total states.")

    visualize_graph(jaris_simulator, ax, filter_state_ids=filtered_ids)
    fig.canvas.draw_idle() # Redraw the figure

def on_show_all_clicked(b):
    """Removes the resonance filter and shows the entire graph."""
    global jaris_simulator
    if jaris_simulator is None:
        with output_area:
            output_area.clear_output(wait=True)
            print("Please initialize or run the simulation first.")
        return

    with output_area:
        output_area.clear_output(wait=True)
        print("Showing all states in the proof graph.")
    visualize_graph(jaris_simulator, ax, filter_state_ids=None) # Pass None to show all
    fig.canvas.draw_idle() # Redraw the figure

def on_save_clicked(b):
    """Saves the current state of the JARIS simulator and proof graph."""
    global jaris_simulator
    if jaris_simulator is None:
        with output_area:
            output_area.clear_output(wait=True)
            print("Nothing to save. Run a simulation first.")
        return

    with output_area:
        output_area.clear_output(wait=True)
        jaris_simulator.save_state()

def on_load_clicked(b):
    """Loads a saved JARIS simulation state."""
    global jaris_simulator
    with output_area:
        output_area.clear_output(wait=True)
        try:
            jaris_simulator = JARISSimulator.load_state()
            # Update widgets to reflect loaded state (optional but good UX)
            initial_symbols_text.value = ','.join(jaris_simulator.initial_state.symbols)
            # Rules text area is harder to reconstruct perfectly, maybe skip or add a note

            visualize_graph(jaris_simulator, ax)
            fig.canvas.draw_idle()
        except FileNotFoundError:
            print("No saved state file 'jaris_proof_state.json' found.")
        except Exception as e:
            print(f"Error loading state: {e}")
            jaris_simulator = None # Clear simulator if loading failed


# Link button clicks to the defined event handlers
step_button.on_click(on_step_clicked)
run_button.on_click(on_run_clicked)
reset_button.on_click(on_reset_clicked)
filter_button.on_click(on_filter_clicked)
show_all_button.on_click(on_show_all_clicked)
save_button.on_click(on_save_clicked)
load_button.on_click(on_load_clicked)

# Arrange the widgets for display in the notebook interface
controls = VBox([
    Label("--- JARIS Computational Proof by Construction ---"),
    initial_symbols_text,
    rules_text,
    HBox([step_button, run_button, reset_button]),
    HBox([resonance_threshold_slider, filter_button, show_all_button]),
    HBox([save_button, load_button])
])

# Display the controls and the output area
display(controls, output_area)

# Initialize the simulator and display the initial graph upon loading the notebook
if initialize_simulator():
    visualize_graph(jaris_simulator, ax)
    display(fig.canvas) # Display the matplotlib figure

# Instructions for the user
with output_area:
    print("Modify 'Initial Symbols' and 'JARIS Flip Rules' above.")
    print("Click 'Simulate 1 Step' to see the proof unfold step-by-step.")
    print("Click 'Simulate to Fixed Point' to run until no new states are generated.")
    print("Use the 'Resonance Threshold' slider and 'Apply Resonance Filter' to focus on high-resonance states.")
    print("'Reset Simulation' restarts with current settings. 'Save/Load Proof State' to resume later.")
    print("\nThe graph below visualizes the 'Computational Proof Trace'.")
    print("Nodes = Symbolic States (Thematic Clusters). Edges = Applied Flips (Computational Steps).")
    print("Green node is the Initial State. Salmon nodes are Convergence Points (Symbolic Resonance).")

